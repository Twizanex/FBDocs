<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>https://developers.facebook.com/docs/samples/canvas/</title>
<link rel="stylesheet" href="/css/common.css" media="screen" />
<script src="/js/common.js"></script>
</head>
<body>
<a id="oklahomer-orig-url" href="https://developers.facebook.com/docs/samples/canvas/">https://developers.facebook.com/docs/samples/canvas/</a>

<div id="oklahomer-menu-wrapper">
<div class="toplevelnav">
<ul>
<li class="active withsubsections">
<a class="selected" href="/docs/" name="https://developers.facebook.com/docs/">
<div class="navSectionTitle">Getting Started</div>
</a>
<ul class="subsections">
<li>
<a href="/docs/guides/web" name="https://developers.facebook.com/docs/guides/web">Websites</a>
</li>
<li>
<a href="/docs/guides/canvas" name="https://developers.facebook.com/docs/guides/canvas">Apps on Facebook</a>
</li>
<li>
<a href="/docs/guides/mobile" name="https://developers.facebook.com/docs/guides/mobile">Mobile</a>
</li>
<li>
<a href="/docs/appcenter/" name="https://developers.facebook.com/docs/appcenter/">App Center</a>
</li>
<li>
<a href="/docs/bestpractices/" name="https://developers.facebook.com/docs/bestpractices/">Best Practices</a>
</li>
<li>
<a href="/docs/samples" name="https://developers.facebook.com/docs/samples">Samples &amp; How-Tos</a>
</li>
<li>
<a href="/videos" name="https://developers.facebook.com/videos">Videos</a>
</li>
</ul>
</li>
<li>
<a href="/docs/coreconcepts" name="https://developers.facebook.com/docs/coreconcepts">
<div class="navSectionTitle">Core Concepts</div>
</a>
</li>
<li>
<a href="/docs/advancedtopics" name="https://developers.facebook.com/docs/advancedtopics">
<div class="navSectionTitle">Advanced Topics</div>
</a>
</li>
<li>
<a href="/docs/sdks" name="https://developers.facebook.com/docs/sdks">
<div class="navSectionTitle">SDK Reference</div>
</a>
</li>
<li>
<a href="/tools" name="https://developers.facebook.com/tools">
<div class="navSectionTitle">Tools</div>
</a>
</li>
</ul>
</div>
<ul id="navsubsectionpages">
<li>
</li>
<li class="active">
<h5>Samples</h5>
<ul>
<li>
<a class="selected" href="http://developers.facebook.com/docs/samples/canvas/" name="http://developers.facebook.com/docs/samples/canvas/">Sample Canvas App</a>
</li>
</ul>
</li>
</ul></div>

<div id="oklahomer-content-wrapper">
<div class="header">
<div class="content">
<h1>Sample Canvas App</h1>
<div class="breadcrumbs">
<a href="/docs/" name="https://developers.facebook.com/docs/">Getting Started</a> › <a href="/docs/samples/" name="https://developers.facebook.com/docs/samples/">Samples &amp; How-Tos</a> › <a href="/docs/samples/canvas/" name="https://developers.facebook.com/docs/samples/canvas/">Sample Canvas App</a>
</div>
</div>
</div>
<h2>Overview</h2>
<p>Run with Friends is a sample <a href="https://developers.facebook.com/docs/guides/canvas/" name="https://developers.facebook.com/docs/guides/canvas/">Facebook Canvas Application</a> written in <a href="http://python.org/" name="http://python.org/">Python</a> running on <a href="http://code.google.com/appengine/" name="http://code.google.com/appengine/">Google App Engine</a>. The application is designed to run within an iframe on a <a href="https://developers.facebook.com/docs/guides/canvas/" name="https://developers.facebook.com/docs/guides/canvas/">Facebook Canvas</a> page.</p>
<p>
<img alt="Canvas Screenshot" src="https://developers.facebook.com/attachment/canvas-sample-main-app.png" width="700px" />
</p>
<p>Facebook provides a large array of integration points for applications and this sample application makes use of only a few of those capabilities. Some of the things that are covered here are:</p>
<ul>
<li>Web based Authentication, specifically using the <a href="https://developers.facebook.com/docs/reference/javascript/" name="https://developers.facebook.com/docs/reference/javascript/">JavaScript SDK</a> and the <a href="https://developers.facebook.com/docs/authentication/canvas" name="https://developers.facebook.com/docs/authentication/canvas">signed_request</a>.</li>
<li>Making use of a <a href="https://developers.facebook.com/plugins" name="https://developers.facebook.com/plugins">Social Plugin</a>, notably the <a href="https://developers.facebook.com/docs/reference/plugins/login" name="https://developers.facebook.com/docs/reference/plugins/login">Login with Faces</a> plugin.</li>
<li>Showing <a href="https://developers.facebook.com/docs/reference/javascript/FB.ui" name="https://developers.facebook.com/docs/reference/javascript/FB.ui">Facebook Dialogs</a> to allow the user to post content back to Facebook.</li>
<li>Making <a href="https://developers.facebook.com/docs/api" name="https://developers.facebook.com/docs/api">Graph API</a> calls using <a href="https://developers.facebook.com/docs/api#authorization" name="https://developers.facebook.com/docs/api#authorization">OAuth 2.0</a>.</li>
<li>Making use of <a href="https://developers.facebook.com/docs/api/realtime" name="https://developers.facebook.com/docs/api/realtime">Real-time Updates</a> in order to keep the cached data up-to-date.</li>
</ul>
<p>You can try the sample at <a href="https://apps.facebook.com/runwithfriends/" name="https://apps.facebook.com/runwithfriends/">https://apps.facebook.com/runwithfriends/</a>
</p>
<hr />
<h2>Requirements</h2>
<p>In order to run the sample, you need the following:</p>
<ul>
<li>
<a href="http://python.org/" name="http://python.org/">Python</a>
</li>
<li>
<a href="http://code.google.com/appengine/downloads.html" name="http://code.google.com/appengine/downloads.html">Google App Engine</a>
</li>
<li>A public URL for your application (in order to use the <a href="https://developers.facebook.com/docs/api/realtime" name="https://developers.facebook.com/docs/api/realtime">Real-time API</a>)</li>
</ul>
<hr />
<h2>Getting Started</h2>
<ol>
<li>
<p>
<a href="https://www.facebook.com/developers/createapp.php" name="https://www.facebook.com/developers/createapp.php">Create a Facebook Application</a>
</p>
</li>
<li>
<p>In the <strong>Web Site</strong> section:</p>
<ul>
<li>Configure the <strong>Site URL</strong>, and point it to your Web Server. If you&apos;re developing locally, you can use <code>http://localhost:8080/</code>
</li>
</ul>
</li>
<li>
<p>In the <strong>Facebook Integration</strong> section:</p>
<ul>
<li>Choose a <strong>Canvas Page</strong> name, which is your application&apos;s URL on facebook.com.</li>
<li>Configure the <strong>Canvas URL</strong>, and point it to your webserver. If you&apos;re developing locally, you can use <code>http://localhost:8080/</code>. This will get used as the iframe src.</li>
<li>Also switch <strong>iframe Size</strong> to <strong>Auto Resize</strong>, since we&apos;ll be using the <a href="https://developers.facebook.com/docs/reference/javascript/" name="https://developers.facebook.com/docs/reference/javascript/">JavaScript SDK</a> to resize our iframe.</li>
</ul>
</li>
<li>
<p>In the <strong>Advanced</strong> section, enable these <strong>Migrations</strong>:</p>
<ul>
<li>OAuth Migration</li>
</ul>
</li>
<li>
<p>
<a href="//github.com/fbsamples/runwithfriends/zipball/master" name="https://github.com/fbsamples/runwithfriends/zipball/master">Download the sample</a>:</p>
<pre>
<code>mkdir runwithfriends
cd runwithfriends
curl -L http://github.com/fbsamples/runwithfriends/tarball/master |
  tar xzvf - --strip-components=1
</code>
</pre>
</li>
<li>
<p>Configure the local settings for your app. Start by copying <code>conf.py.example</code> to <code>conf.py</code>, then edit the various values in the <code>conf.py</code>:</p>
<pre>
<code>cp conf.py.example conf.py
vim conf.py
</code>
</pre>
</li>
<li>
<p>Add the application to the <a href="http://code.google.com/appengine/downloads.html" name="http://code.google.com/appengine/downloads.html">App Engine Launcher</a> and start it (or start it from the command line):</p>
<pre>
<code>dev_appserver.py .
</code>
</pre>
</li>
<li>
<p>Go to <a href="http://localhost:8080/" name="http://localhost:8080/">localhost:8080</a>
</p>
</li>
</ol>
<hr />
<h2>The User Model</h2>
<p>One of the main benefits of integrating with Facebook is the ease with which you can use the user&apos;s real identity provided by Facebook, and the wealth of existing user data that is <a href="https://developers.facebook.com/docs/api" name="https://developers.facebook.com/docs/api">made available</a>. For the sample application, we used a few different pieces of data to represent the <em>User</em>:</p>
<ul>
<li>Facebook User ID - the core <em>stable</em> identifier for a user</li>
<li>Name</li>
<li>Email</li>
<li>Profile Picture</li>
<li>Friends (set of Facebook User IDs for that are friends with the user)</li>
</ul>
<p>The first step to getting this information is having the user <a href="https://developers.facebook.com/docs/authentication/" name="https://developers.facebook.com/docs/authentication/">authorize your application</a> and grant it the necessary <a href="https://developers.facebook.com/docs/authentication/permissions" name="https://developers.facebook.com/docs/authentication/permissions">permissions</a>. The result of granting these permissions gives you the <code>access_token</code> which enables access to the <a href="https://developers.facebook.com/docs/api" name="https://developers.facebook.com/docs/api">APIs</a> that will give you the above data.</p>
<p>In the sample application we&apos;ve opted to represent all this information as part of the User model, and is defined as:</p>
<pre>
<code>class User(db.Model):
    user_id = db.StringProperty(required=True)
    access_token = db.StringProperty(required=True)
    name = db.StringProperty(required=True)
    picture = db.StringProperty(required=True)
    email = db.StringProperty()
    friends = db.StringListProperty()
    dirty = db.BooleanProperty()
</code>
</pre>
<hr />
<h2>signed_request Parameter</h2>
<p>The typical flow for a user when using the application begins with the user landing at some Canvas URL, like <a href="https://apps.facebook.com/runwithfriends/" name="https://apps.facebook.com/runwithfriends/">https://apps.facebook.com/runwithfriends/</a>. At this point, Facebook will load up it&apos;s chrome, and render a <code>&lt;iframe&gt;</code> tag to your application. You&apos;ll notice there isn&apos;t a <code>src</code> specified. Using some JavaScript and the <code>&lt;form&gt;</code> tag, Facebook triggers a <code>POST</code> request to your application. This is done for security reasons, as the sensitive user data won&apos;t be sent via the HTTP Referrer header as long it&apos;s sent as <code>POST</code> data. Additionally, in order to ensure the data Facebook sends over is not tampered with, it provides a signed JSON data structure, which is signed using the application secret. The parameter is called <a href="https://developers.facebook.com/docs/authentication/canvas" name="https://developers.facebook.com/docs/authentication/canvas">signed_request</a>, and sample application uses this to load it:</p>
<pre>
<code>def load_signed_request(self, signed_request):
    &quot;&quot;&quot;Load the user state from a signed_request value&quot;&quot;&quot;
    sig, payload = signed_request.split(u&apos;.&apos;, 1)
    sig = self.base64_url_decode(sig)
    data = json.loads(self.base64_url_decode(payload))

    expected_sig = hmac.new(
        self.app_secret, msg=payload, digestmod=hashlib.sha256).digest()

    # allow the signed_request to function for upto 1 day
    if sig == expected_sig and data[u&apos;issued_at&apos;] &gt; (time.time() - 86400):
        self.signed_request = data
        self.user_id = data.get(u&apos;user_id&apos;)
        self.access_token = data.get(u&apos;oauth_token&apos;)
</code>
</pre>
<p>When Facebook sends the initial <code>POST</code> request, if it detects that the user has already authorized your application, it will include the User ID and the <code>access_token</code> as part of the <code>signed_request</code> parameter. The application uses this information, and sets an internal auth cookie named <code>u</code>. We choose to use the same format as for the cookie value as the <code>signed_request</code> parameter in order to simplify/reuse our authentication code. The <code>signed_request</code> parameter is <a href="https://developers.facebook.com/docs/authentication/canvas" name="https://developers.facebook.com/docs/authentication/canvas">documented at length in the official documentation</a>.</p>
<p>The sample application uses this to initialize the Facebook instance, and if possible the User instance on <strong>every</strong> request:</p>
<pre>
<code>def init_facebook(self):
    &quot;&quot;&quot;Sets up the request specific Facebook and User instance&quot;&quot;&quot;
    facebook = Facebook()
    user = None

    # initial facebook request comes in as a POST with a signed_request
    if u&apos;signed_request&apos; in self.request.POST:
        facebook.load_signed_request(self.request.get(&apos;signed_request&apos;))
        self.request.method = u&apos;GET&apos;  # causes loss of request.POST data
        self.set_cookie(
            &apos;u&apos;, facebook.user_cookie, datetime.timedelta(minutes=1440))
    elif &apos;u&apos; in self.request.cookies:
        facebook.load_signed_request(self.request.cookies.get(&apos;u&apos;))

    # try to load or create a user object
    if facebook.user_id:
        user = User.get_by_key_name(facebook.user_id)
        if user:
            # update stored access_token
            if facebook.access_token and \
                    facebook.access_token != user.access_token:
                user.access_token = facebook.access_token
                user.put()
            # refresh data if we failed in doing so after a realtime ping
            if user.dirty:
                user.refresh_data()
            # restore stored access_token if necessary
            if not facebook.access_token:
                facebook.access_token = user.access_token

        if not user and facebook.access_token:
            me = facebook.api(u&apos;/me&apos;, {u&apos;fields&apos;: u&apos;picture,friends&apos;})
            logging.info(u&apos;/me API call response: &apos; + unicode(me))
            user = User(key_name=facebook.user_id,
                user_id=facebook.user_id,
                access_token=facebook.access_token,
                name=me[u&apos;name&apos;],
                email=me.get(u&apos;email&apos;),  # optional
                picture=me[u&apos;picture&apos;],
                friends=[user[u&apos;id&apos;] for user in me[u&apos;friends&apos;][u&apos;data&apos;]])
            user.put()

    self.facebook = facebook
    self.user = user
</code>
</pre>
<p>There are a several important decisions here that ensure a smooth experience for users:</p>
<ol>
<li>We <strong>prefer the <code>signed_request</code> sent in the <code>POST</code>
</strong> rather than a cookie value. If we don&apos;t find <code>signed_request</code> in the <code>POST</code> data, we lookup the cookie value instead.</li>
<li>We set a <strong>cookie on every <code>POST</code> that includes a <code>signed_request</code>
</strong>. This ensures we persist the last well known user state.</li>
<li>We reset the method to <code>GET</code> when we get a <code>POST</code> with the <code>signed_request</code>. Facebook will always send a <code>POST</code> on the initial iframe request for security reasons, and this can be to any end-point in our application, while in reality, this should be treated as a <code>GET</code>. By resetting the method to <code>GET</code>, we make the rest of our application ignorant of this behaviour.</li>
<li>While we use the <code>signed_request</code> format in the cookie, this is not a Facebook requirement. You could use your own session storage without any consequences, and all that is required is that you store the Facebook <code>user_id</code> to identify the logged in user. Just remember to prefer the <code>signed_request</code> in <code>POST</code> if it&apos;s there and update your session the same way as the cookie is updated.</li>
<li>We don&apos;t simply set the <code>signed_request</code> value we get in the <code>POST</code> as the cookie because it will contain the <code>access_token</code> and may be large. Instead, we simply store the <code>user_id</code> in the cookie, and load the stored <code>access_token</code> from the user object as needed.</li>
<li>If we get a <code>signed_request</code> in the <code>POST</code>, we update the stored <code>access_token</code> with the freshly received one if it isn&apos;t the same, always assuming it&apos;s the better one of the two.</li>
<li>If we don&apos;t find a stored user, and the request included an <code>access_token</code>, we&apos;ll create the user object.</li>
<li>The <code>dirty</code> bit is used along with the <a href="https://developers.facebook.com/docs/api/realtime" name="https://developers.facebook.com/docs/api/realtime">Real-time API</a> which is described further below.</li>
</ol>
<hr />
<h2>Login with Faces</h2>
<p>Authentication with Facebook involves sending the user to <code>facebook.com</code> and having Facebook prompt them to authorize the application. The simplest way to do so is to redirect the user&apos;s browser to <code>facebook.com</code> with some parameters, and have the user come back after they&apos;ve taken an action. If you want to go the manual route, the <a href="https://developers.facebook.com/docs/authentication/#web_server_auth" name="https://developers.facebook.com/docs/authentication/#web_server_auth">documentation for authenticating users in a web application</a> will provide the easiest path. In the sample application we&apos;ve opted to use the <a href="https://developers.facebook.com/docs/reference/plugins/login" name="https://developers.facebook.com/docs/reference/plugins/login">login with faces</a> plugin via the <a href="https://developers.facebook.com/docs/reference/javascript/" name="https://developers.facebook.com/docs/reference/javascript/">JavaScript SDK</a> to provide a richer experience. The plugin will show a login button, and the faces of the friends who have used the application (if possible). The data is not actually made available to the application yet, the social context is provided by using an iframe to <code>facebook.com</code>. This is done via XFBML, a client side markup language supported by the <a href="https://developers.facebook.com/docs/reference/javascript/" name="https://developers.facebook.com/docs/reference/javascript/">JavaScript SDK</a>:</p>
<pre>
<code>&lt;fb:login-button perms=&quot;email,offline_access&quot;
                 show-faces=&quot;true&quot;&gt;&lt;/fb:login-button&gt;
</code>
</pre>
<p>The result of which is:</p>
<p>
<img alt="Login with Faces" src="https://developers.facebook.com/attachment/canvas-sample-login-with-faces.png" width="700px" />
</p>
<p>Notice the <code>perms</code> attribute on the tag -- this lists the <a href="https://developers.facebook.com/docs/authentication/permissions" name="https://developers.facebook.com/docs/authentication/permissions">extended permissions</a> we&apos;ll need the user to grant our application in order for it to function. Upon clicking the <strong>Login</strong> button, the user will be shown a popup dialog to grant your application the requested permissions:</p>
<p>
<img alt="Permissions Dialog" src="https://developers.facebook.com/attachment/canvas-sample-permissions-dialog.png" />
</p>
<p>The sample application requests extended permissions, but doesn&apos;t actually need it! Ideally you should ask for no additional permissions when the user initially authorizes your application, and keep the list of things in the above dialog short. You can ask for <a href="https://developers.facebook.com/docs/reference/javascript/FB.login" name="https://developers.facebook.com/docs/reference/javascript/FB.login">additional permissions</a> even after the user has already authorized your application for basic information. Requesting minimal permissions will mean a <strong>greater initial conversion</strong>, giving you the opportunity to provide the user with an experience which makes for a more compelling backdrop when you ask for the additional permissions at a later point in time.</p>
<hr />
<h2>Authentication Events</h2>
<p>JavaScript is a heavily event driven environment, and the <a href="https://developers.facebook.com/docs/reference/javascript/" name="https://developers.facebook.com/docs/reference/javascript/">JavaScript SDK</a> embraces that nature and provides it&apos;s own events. Notably, there are two useful event&apos;s we care about in the authentication context: <code>auth.login</code> and <code>auth.logout</code>. The <a href="https://developers.facebook.com/docs/reference/javascript/" name="https://developers.facebook.com/docs/reference/javascript/">JavaScript SDK</a> fires these in response to various interactions, including a login action from the <code>&lt;fb:login-button&gt;</code>. These can be subscribed to as:</p>
<pre>
<code>FB.Event.subscribe(&apos;auth.login&apos;, function(response) {
  // Reload the entire page. Could also do an Ajax request and dynamically
  // update the already loaded page.
  window.location.reload(true);
});

FB.Event.subscribe(&apos;auth.logout&apos;, function() {
  // Do something...
});
</code>
</pre>
<p>These events let you do some custom work whenever a relevant change happens. Remember to be careful about <em>when</em> you subscribe to these events. It&apos;s usually ideal to invoke <a href="https://developers.facebook.com/docs/reference/javascript/FB.Event.subscribe" name="https://developers.facebook.com/docs/reference/javascript/FB.Event.subscribe">FB.Event.subscribe()</a> right after the <a href="https://developers.facebook.com/docs/reference/javascript/FB.init" name="https://developers.facebook.com/docs/reference/javascript/FB.init">FB.init()</a> call. For most applications which do the heavy lifting on the server side, you&apos;ll typically just want to reload the top frame and have Facebook send you a <code>signed_request</code> with the user&apos;s credentials, and let the server render the logged in view. This is what the sample application does:</p>
<pre>
<code>function handleSessionChange(response) {
  if ((Config.userIdOnServer &amp;&amp; !response.session) ||
      Config.userIdOnServer != response.session.uid) {
    top.location = &apos;https://apps.facebook.com/&apos; + Config.canvasName + &apos;/&apos;;
  }
}
FB.Event.subscribe(&apos;auth.sessionChange&apos;, handleSessionChange);
</code>
</pre>
<p>The sample application also handles in-flight user changes. It does this by comparing the <code>user_id</code> of the logged in user when the server rendered the page (or lack there of) with the <code>user_id</code> based on the auth events in JavaScript (which is doing a live check against <code>facebook.com</code> and is more accurate out of the two).</p>
<hr />
<h2>Cookies in iframes/P3P Header</h2>
<p>Some browsers will let iframes set cookies based on the presence of the <a href="http://en.wikipedia.org/wiki/P3P" name="http://en.wikipedia.org/wiki/P3P">P3P header</a>. Notably, IE respects this header. Ideally you may want to look up the right value based on the privacy policy adopted by your application, but any value will usually suffice. The sample application sends this for instance:</p>
<pre>
<code>P3P: CP=&quot;HONK&quot;
</code>
</pre>
<hr />
<h2>Graph API</h2>
<p>The <a href="https://developers.facebook.com/docs/api" name="https://developers.facebook.com/docs/api">Graph API</a> provides a RESTful interface to the Facebook API. The API makes a wealth of information available, assuming you&apos;ve requested the necessary <a href="https://developers.facebook.com/docs/authentication/permissions" name="https://developers.facebook.com/docs/authentication/permissions">extended permissions</a>. The basic access pattern to use the API is:</p>
<pre>
<code>https://graph.facebook.com/[PATH]?access_token=[TOKEN]&amp;[PARAMS...]
</code>
</pre>
<p>The Facebook class provides a simple interface to access the Facebook API. This may not be sufficient for more advance use cases (such as file uploads):</p>
<pre>
<code>def api(self, path, params=None, method=u&apos;GET&apos;, domain=u&apos;graph&apos;):
    &quot;&quot;&quot;Make API calls&quot;&quot;&quot;
    if not params:
        params = {}
    params[u&apos;method&apos;] = method
    if u&apos;access_token&apos; not in params and self.access_token:
        params[u&apos;access_token&apos;] = self.access_token
    result = json.loads(urlfetch.fetch(
        url=u&apos;https://&apos; + domain + u&apos;.facebook.com&apos; + path,
        payload=urllib.urlencode(params),
        method=urlfetch.POST,
        headers={
            u&apos;Content-Type&apos;: u&apos;application/x-www-form-urlencoded&apos;}).content)
    if isinstance(result, dict) and u&apos;error&apos; in result:
        raise FacebookApiError(result)
    return result
</code>
</pre>
<p>Note, here we&apos;re using the <code>method</code> override, that is, specifying the method as a parameter to specify the intended HTTP method as a convenience.</p>
<h3>Getting the User data</h3>
<p>Once we have a Facebook <code>user_id</code> and <code>access_token</code>, we can make use of that to populate our user object using the API method described above. Here&apos;s what the sample application does to fetch the date we care about. Notice we request the additional picture field, as well as the friends data as part of the single API call. Additionally, you&apos;ll notice <code>email</code> is not actually required, but will be populated if it&apos;s available. We do not need to do the same for name, picture and friends as that is part of the minimal set of information made available when a user authorizes your application.</p>
<pre>
<code>me = self.facebook.api(u&apos;/me&apos;, {u&apos;fields&apos;: u&apos;picture,friends&apos;})
logging.info(u&apos;/me API call response: &apos; + unicode(me))
user = User(key_name=self.facebook.user_id,
    user_id=self.facebook.user_id,
    access_token=self.facebook.access_token,
    name=me[u&apos;name&apos;],
    email=me.get(u&apos;email&apos;),  # optional
    picture=me[u&apos;picture&apos;],
    friends=[user[u&apos;id&apos;] for user in me[u&apos;friends&apos;][u&apos;data&apos;]])
user.put()
</code>
</pre>
<p>The Graph API provides a simple interface to a <a href="https://developers.facebook.com/docs/api" name="https://developers.facebook.com/docs/api">wealth of facebook data</a>. The sample application uses only some <a href="https://developers.facebook.com/docs/reference/api/user" name="https://developers.facebook.com/docs/reference/api/user">basic user information, including the user&apos;s friends list</a>, but after <a href="https://developers.facebook.com/docs/authentication/permissions" name="https://developers.facebook.com/docs/authentication/permissions">requesting the right set of permissions</a>, you can access the user&apos;s <a href="https://developers.facebook.com/docs/reference/api/photo" name="https://developers.facebook.com/docs/reference/api/photo">photos</a>, <a href="https://developers.facebook.com/docs/reference/api/event" name="https://developers.facebook.com/docs/reference/api/event">events</a>, <a href="https://developers.facebook.com/docs/reference/api/group" name="https://developers.facebook.com/docs/reference/api/group">groups</a>, <a href="https://developers.facebook.com/docs/reference/api/checkin" name="https://developers.facebook.com/docs/reference/api/checkin">checkins</a> and <a href="https://developers.facebook.com/docs/api" name="https://developers.facebook.com/docs/api">a lot more</a>.</p>
<hr />
<h2>Dialogs</h2>
<p>Once the user successfully posts a run, we want to provide them with the option to post a story to Facebook. Again, you could manually popup a window to the dialog, we can provide a richer user experience by making use of the <a href="https://developers.facebook.com/docs/reference/javascript/" name="https://developers.facebook.com/docs/reference/javascript/">JavaScript SDK</a> and making use of <a href="https://developers.facebook.com/docs/reference/javascript/FB.ui" name="https://developers.facebook.com/docs/reference/javascript/FB.ui">FB.ui()</a>.</p>
<p>Here&apos;s what the sample application uses to publish the story:</p>
<pre>
<code>function publishRun(title) {
  FB.ui({
    method: &apos;stream.publish&apos;,
    attachment: {
      name: title,
      caption: &quot;I&apos;m running!&quot;,
      media: [{
        type: &apos;image&apos;,
        href: &apos;http://runwithfriends.appspot.com/&apos;,
        src: &apos;http://runwithfriends.appspot.com/splash.jpg&apos;
      }]
    },
    action_links: [{
      text: &apos;Join the Run&apos;,
      href: &apos;http://runwithfriends.appspot.com/&apos;
    }],
    user_message_prompt: &apos;Tell your friends about the run:&apos;
  });
}
</code>
</pre>
<p>After the user adds a Run, we show the user a confirmation message with a link that triggers this function, and results in an experience like such:</p>
<p>
<img alt="Publish Dialog" src="https://developers.facebook.com/attachment/canvas-sample-publish-dialog.png" width="700px" />
</p>
<p>The stream publish dialog provides an easy, intentional user action that allows your application to post content back to Facebook. The API allows you to specify various attributes that control the display and the behaviour of the posts. As this process already involves an explicit user interaction, you are able to make use of this without permissions of any sort. In fact, you can show the popup version of the stream publish dialog even before the user has authorized your application.</p>
<hr />
<h2>Real-time Updates</h2>
<p>Our approach to use the basic user data is to make an API call to Facebook and cache the data in our application&apos;s local data store. We also subscribe to the <a href="https://developers.facebook.com/docs/api/realtime" name="https://developers.facebook.com/docs/api/realtime">Real-time API</a> which notifies us when the data we care about changes, and App Engine provided <a href="http://code.google.com/appengine/docs/python/taskqueue/overview.html" name="http://code.google.com/appengine/docs/python/taskqueue/overview.html">Task Queues</a> to manage the updates that should be triggered based on the pings. The two together allow us to provide a vastly improved user experience as we no longer need to make expensive HTTP calls as the user is using the application, but yet always have the most up-to-date information about the user including their name, email, profile picture and list of friends as long as the user is actively using our application.</p>
<p>We use a two fold approach here. We store the <code>access_token</code> we get when the user visits the application, and will try to use that to make an API call to refresh the user data in a background task when we are notified of changes. If this API call fails, we&apos;ll flip the <code>dirty</code> bit on the user instance. This will mean we&apos;ll use some stale data for the user, until they visit the application the next time around at which point we&apos;ll have a fresh <code>access_token</code>, and we&apos;ll notice the <code>dirty</code> bit and trigger a refresh of the data. We use the two fold system despite the fact that we ask for the <code>offline_access</code> permission (which in theory means indefinite access). It is always a good idea to handle the case where the stored <code>access_token</code> is no longer valid, which can happen for various reasons (user explicitly revoked access, token expired and a few others).</p>
<p>The process of using the <a href="https://developers.facebook.com/docs/api/realtime" name="https://developers.facebook.com/docs/api/realtime">Real-time API</a> begins with subscribing to object families. Our application subscribes to the <code>user</code> object, and specifically the <code>[&apos;email&apos;, &apos;name&apos;, &apos;picture&apos;, &apos;friends&apos;]</code> fields.</p>
<p>For our sample application, we&apos;ve setup an internal end-point that enables us to trigger the subscription setup flow. Simply visit <a href="http://localhost:8080/realtime?setup=1" name="http://localhost:8080/realtime?setup=1">http://localhost:8080/realtime?setup=1</a>. If you get an error message, ensure you&apos;ve added your own Facebook User ID to the <code>ADMIN_USER_IDS</code> in <code>conf.py</code>, and that you&apos;re logged into the application. This is our poor mans admin system.</p>
<p>The sample application uses this to setup the subscription:</p>
<pre>
<code>def setup_subscription(self):
    path = u&apos;/&apos; + conf.FACEBOOK_APP_ID + u&apos;/subscriptions&apos;
    params = {
        u&apos;access_token&apos;: conf.FACEBOOK_APP_ID + u&apos;|&apos; +
                         conf.FACEBOOK_APP_SECRET,
        u&apos;object&apos;: u&apos;user&apos;,
        u&apos;fields&apos;: u&apos;name,email,picture,friends&apos;,
        u&apos;callback_url&apos;: conf.EXTERNAL_HREF + u&apos;realtime&apos;,
        u&apos;verify_token&apos;: conf.FACEBOOK_REALTIME_VERIFY_TOKEN,
    }
    response = self.facebook.api(path, params, u&apos;POST&apos;)
    logging.info(u&apos;Real-time setup API call response: &apos; + unicode(response))
</code>
</pre>
<p>Here we&apos;re making an <strong>application secret</strong> enabled call, as can be seen by the fact that we&apos;re using <strong>application ID</strong> and the <strong>application secret</strong> as the <code>access_token</code>. We are informing Facebook&apos;s <a href="https://developers.facebook.com/docs/api/realtime" name="https://developers.facebook.com/docs/api/realtime">Real-time API</a> service about our configuration, including the objects and fields we want to get change notifications about, as well as the endpoint to hit. <strong>Be careful</strong>, you&apos;ll need to ensure the <code>EXTERNAL_HREF</code> has been configured correctly, and is a end-point that can be reached from anywhere on the internet. This means you <em>cannot</em> use something like <code>http://localhost:8080/</code> here, because that is not an end-point Facebook&apos;s servers can reach. Once you&apos;ve triggered the setup, you&apos;ll receive a background ping from Facebook&apos;s servers to confirm the subscription after which you&apos;ll start receiving change notifications.</p>
<p>Here&apos;s the top level entry point for our <a href="https://developers.facebook.com/docs/api/realtime" name="https://developers.facebook.com/docs/api/realtime">Real-time API</a> change notifications:</p>
<pre>
<code>def post(self):
    body = self.request.body
    logging.info(u&apos;Real-time ping: &apos; + body)
    if self.request.headers[u&apos;X-Hub-Signature&apos;] != (u&apos;sha1=&apos; + hmac.new(
        self.facebook.app_secret,
        msg=body,
        digestmod=hashlib.sha1).hexdigest()):
        logging.error(
            u&apos;Real-time signature check failed: &apos; + unicode(self.request))
        return
    data = json.loads(body)

    if data[u&apos;object&apos;] == u&apos;user&apos;:
        for entry in data[u&apos;entry&apos;]:
            taskqueue.add(url=u&apos;/task/refresh-user/&apos; + entry[u&apos;id&apos;])
            logging.info(&apos;Added task to queue to refresh user data.&apos;)
    else:
        logging.warn(u&apos;Unhandled Real-time ping: &apos; + body)
</code>
</pre>
<p>First we ensure that the signature of the ping matches can be verified based on our application secret. As we&apos;re only subscribing to <strong>user object</strong> changes, we have only implemented the same, and log a warning if another type of notification is received.</p>
<p>The other interesting aspect here is that we may get batches of changes, as represented by the <code>entry</code> property in the notification, which is an array of objects. The Real-time API needs confirmation when you&apos;ve handled the ping. Success is indicated by simply returning a 200 response within 10 seconds. This coupled with the large batch sizes means we cannot do the work of refreshing the user data in the same request that receives the Real-time ping as we would not have enough time. Additionally, App Engine itself restricts each request to 30 seconds or so, which would be another limitation. So we simply queue up independent tasks for each <code>user_id</code> mentioned in the ping, and do the work of refreshing the data in the background task. Ideally, we&apos;ll be successful in refreshing the data, but if we&apos;re not, we mark the user instance as <code>dirty</code> to trigger a refresh the next time the user visits our application.</p>
<pre>
<code>class RefreshUserHandler(BaseHandler):
    &quot;&quot;&quot;Refresh user data using if possible.&quot;&quot;&quot;
    def post(self, user_id):
        logging.info(&apos;Refreshing user data for &apos; + user_id)
        user = User.get_by_key_name(user_id)
        if not user:
            return
        try:
            user.refresh_data()
        except FacebookApiError:
            user.dirty = True
            user.put()
</code>
</pre>
<p>This process keeps our internal copy of the user data up-to-date, and essentially enables us to limit ourselves to invoking the Facebook Graph API only at sign-up time and when we notice changes, and using cached data for the rest of the page loads.</p>
<hr />
<h2>Discussion</h2>
<iframe frameborder="0" height="150px" name="samples" scrolling="no" src="https://www.facebook.com/plugins/feedback.php?href=http%3A%2F%2Fdevelopers.facebook.com%2Fdocs%2Fsamples%2Fcanvas&amp;permalink=0&amp;limit=0" width="680px">
</iframe>
<div class="mtl pvm uiBoxWhite topborder">
<div class="mbm lfloat">
<fb:like href="http://developers.facebook.com/docs/samples/canvas/" send="true" show_faces="false">
</fb:like>
</div>
<div class="clear">
<abbr class="timestamp" data-utime="1337820282" title="2012年5月23日 17:44">約2週間前に更新</abbr>
</div>
</div></div>

</body>
</html>
